
-------- Weitergeleitete Nachricht --------

typedef struct /* Euclidean Point Structure */
{
    f64 x, y;
} T_POINT;

typedef struct /* Homogeneous Point Structure */
{
    f64 x, y, w;
} T_HOM_POINT;

typedef struct  /* Matrix Structure */
{
    f64 Mat[3][3];
} T_MATRIX;

/* Set a Matrix */
void SetMatrix(T_MATRIX* M, f64* Mat)
{
    M->Mat[0][0] = Mat[0]; M->Mat[0][1] = Mat[1]; M->Mat[0][2] = Mat[2];
    M->Mat[1][0] = Mat[3]; M->Mat[1][1] = Mat[4]; M->Mat[1][2] = Mat[5];
    M->Mat[2][0] = Mat[6]; M->Mat[2][1] = Mat[7]; M->Mat[2][2] = Mat[8];
}

/* Convert two Values into a Point */
T_POINT ConvPoint(f64 x, f64 y)
{
    T_POINT P;
    P.x = x;    P.y = y;
    return P;
}

/* Convert three Values into a Homogeneous Point */
T_HOM_POINT ConvHomPoint(f64 x, f64 y, f64 w)
{
    T_HOM_POINT P;
    P.x = x;    P.y = y;    P.w = w;
    return P;
}

void MatMul(f64* A, f64* B, f64* Res)
{
    int x, y, z;
    f64 fval;

    for (y = 0; y < 3; y++)
    {
        for (x = 0; x < 3; x++)
        {
            fval = 0;
            for (z = 0; z < 3; z++) fval += A[x + z * 3] * B[z + y * 3];
            Res[x + y * 3] = fval;
        }
    }
}

void MatCpy(f64* Src, f64* Dst)
{
    int x, y;

    for (y = 0; y < 3; y++)
    {
        for (x = 0; x < 3; x++) Dst[x + y * 3] = Src[x + y * 3];
    }
}

void MatInv(f64* Src, f64* Dst)
{
    f64 det, a, b, c, d, e, f, g, h, i;

    a = Src[0];
    b = Src[1];
    c = Src[2];
    d = Src[3];
    e = Src[4];
    f = Src[5];
    g = Src[6];
    h = Src[7];
    i = Src[8];
    det = a * e * i + b * f * g + c * d * h - g * e * c - h * f * a - i * d * b;

    Dst[0] = (e * i - h * f) / det;
    Dst[1] = -(b * i - h * c) / det;
    Dst[2] = (b * f - e * c) / det;
    Dst[3] = -(d * i - g * f) / det;
    Dst[4] = (a * i - g * c) / det;
    Dst[5] = -(a * f - d * c) / det;
    Dst[6] = (d * h - g * e) / det;
    Dst[7] = -(a * h - g * b) / det;
    Dst[8] = (a * e - d * b) / det;

}


void Map2Img(u32* map, Mat& CImg)
{
    int x, y;
    u32 val;
    for (y = 0; y < 384; y++)
    {
        for (x = 0; x < 512; x++)
        {
            val = map[x + (y << 9)];
            *(CImg.ptr(y, x)+ 2) = val & 0xFF;
            val >>= 8;
            *(CImg.ptr(y, x)+ 1) = val & 0xFF;
            val >>= 8;
            *(CImg.ptr(y, x)+ 0) = val & 0xFF;
        }
    }
}

void Img2Map(Mat& CImg, u32* map)
{
    int x, y;
    u32 val;
    for (y = 0; y < 384; y++)
    {
        for (x = 0; x < 512; x++)
        {
            if (x < CImg.cols)
            {
                map[x + (y << 9)] = *(CImg.ptr(y, x)+ 2) + (*(CImg.ptr(y,x)+ 1) << 8) + (*(CImg.ptr(y, x) + 0) << 16);
            }
        }
    }
}


/*---------------------------------- Optimize here !!! ----------------------------------------------- */


/* Homogeneous Matrix Multiplication */
void HomMatMul(T_MATRIX H, T_HOM_POINT HP_S, T_HOM_POINT* HP_D)
{
    HP_D->x = H.Mat[0][0] * HP_S.x + H.Mat[0][1] * HP_S.y + H.Mat[0][2] * HP_S.w;
    HP_D->y = H.Mat[1][0] * HP_S.x + H.Mat[1][1] * HP_S.y + H.Mat[1][2] * HP_S.w;
    HP_D->w = H.Mat[2][0] * HP_S.x + H.Mat[2][1] * HP_S.y + H.Mat[2][2] * HP_S.w;
}

/* Transform Homogeneous Point into Euclideon Point */
void Hom2Euclid(T_HOM_POINT HP, T_POINT* P)
{
    f64 Epsilon = 0.00000000000000000000000000000000000001;
    if (fabs(HP.w) > Epsilon) P->x = HP.x / HP.w; else P->x = 0;
    if (fabs(HP.w) > Epsilon) P->y = HP.y / HP.w; else P->y = 0;
}

/* Transform Euclidean Point into Homogeneous Point */
void Euclid2Hom(T_POINT P, T_HOM_POINT* HP)
{
    HP->x = P.x;    HP->y = P.y;    HP->w = 1.0;
}

/* Get the Color col at Point P */
int GetPixel(u32* img, T_POINT P, int col)
{
    u32 pixel;
    u8* channel;
    int ofs = P.x + P.y * 512;

    if (img == NULL || col < 0 || col>2 || P.x < 0 || P.y < 0 || P.x>511 || P.y>383) return 0;
    pixel = img[ofs];            /* Get Pixel */
    channel = (u8*)(&pixel);    /* Access Channels */
    return channel[2 - col];        /* return chosen Color */
}

/* Write the Value val into the Color Channel col at Point P */
void PutPixel(u32* img, T_POINT P, int col, int val)
{
    u32 pixel;
    u8* channel;
    int ofs = P.x + P.y * 512;

    if (img == NULL || col < 0 || col>2 || P.x < 0 || P.y < 0 || P.x>511 || P.y>383 || val < 0 || val>255) return;
    pixel = img[ofs];            /* Get Pixel */
    channel = (u8*)(&pixel);        /* Access Channels */
    channel[2 - col] = val;                /* Write chosen Channels */
    img[ofs] = pixel;                /* Write Pixel back into Memory */
}

/* Bilinear Interpolation at Point P using sorrounding 4 Values */
int ComputeBiLinInt(T_POINT P, int v1, int v2, int v3, int v4)
{
    f64 s = P.x - (int)P.x;
    f64 t = P.y - (int)P.y;
    f64 fval = 0;

    if (s >= 0 && s < 1 && t >= 0 && t < 1) /* Test s and t values */
    {
        fval += (1 - s) * (1 - t) * v1;        fval += s * (1 - t) * v2;
        fval += (1 - s) * t * v3;        fval += s * t * v4;
    }
    return (int)fval;
}

/* Process all Transformations */
void CalcHom_Bad(u32* pSrc, u32* pDst, f64* M1, f64* M2, f64* M3, f64* M4, f64* M5, f64* M6, f64* M7)
{
    int x, y, z, col, ix, iy, val;
    int v[4];             /* Array for Color Values of Bilinear Interpolation */
    int dx[4] = { 0,1,0,1 }; /* Lookuptable for x-Koordiantes of Bilinear Interpolation */
    int dy[4] = { 0,0,1,1 }; /* Lookuptable for y-Koordiantes of Bilinear Interpolation */
    T_POINT PT;          /* Euclidean Points */
    T_HOM_POINT HP, HP2;  /* Homogenious Points */
    T_MATRIX M[7];       /* 7 Matrices */

    /* Set Matrices into Matrix Structure for simple Matrix Multiplikation */
    SetMatrix(&M[0], M1);    SetMatrix(&M[1], M2); SetMatrix(&M[2], M3);
    SetMatrix(&M[3], M4);    SetMatrix(&M[4], M5); SetMatrix(&M[5], M6); SetMatrix(&M[6], M7);
    /* Algorithm */
    for (col = 0; col < 3; col++)     /* For each Color */
    {
        for (x = 0; x < 512; x++)     /* For each column */
        {
            for (y = 0; y < 384; y++) /* For each row */
            {
                Euclid2Hom(ConvPoint(x, y), &HP);        /* Transform Euclidean Point into Homogeneous Point */
                for (z = 0; z < 7; z++)                    /* For each Matrix */
                {
                    HomMatMul(M[z], HP, &HP2);        /* Do Matrix Multiplikation */
                    HP = ConvHomPoint(HP2.x, HP2.y, HP2.w);
                }
                Hom2Euclid(HP, &PT);                /* Convert a Homogeneous Point back into Euclidean Space */
                ix = (int)PT.x;    iy = (int)PT.y;        /* Compute Integer Positions */
                if (ix >= 0 && ix < 510 && iy >= 0 && iy < 382)      /* Pixel within Source Image? */
                {
                    /* Get 4 Pixels for Bilinear Interpolation */
                    for (z = 0; z < 4; z++) v[z] = GetPixel(pSrc, ConvPoint(ix + dx[z], iy + dy[z]), col);
                    val = ComputeBiLinInt(PT, v[0], v[1], v[2], v[3]);    /* Do the Bilinear Interpolation */
                    if (val < 0 || val > 255) val = 0;                 /* Check Color Value */
                    PutPixel(pDst, ConvPoint(x, y), col, val);     /* Set Destination Pixel */
                }
                else  PutPixel(pDst, ConvPoint(x, y), col, 0);     /* Set Destination Pixel to Black */
            }
        }
    }
}

/*---------------------------------- Optimize until here !!! ----------------------------------------------- */

void TestHomography(const char* name)
{
    u32* pSrc = new u32[0x30000];
    u32* pDst = new u32[0x30000];

    int x, y, t;
    f64 angle = 30 * 3.14159265358979323846 / 180;    // Rotatinswinkel
    f64 dx = 150;                                    // Translation in X-Richtung
    f64 dy = 120;                                    // Translation in Y-Richtung
    f64 skw = 0.1;                                // Scherung in X-Richtung
    f64 scale = 1.1;                                // Scalierung
    f64 px = 0.001;                                // Projektive Verzerurung in X-Richtung
    f64 py = 0.001;                                // Projektive Verzerurung in Y-Richtung

    /* Compute Transformation Matrices */
    f64 Rot[9] = { cos(angle),sin(angle),0,-sin(angle),cos(angle),0,0,0,1 };
    f64 Trans[9] = { 1,0,dx,0,1,dy,0,0,1 };
    f64 MovFw[9] = { 1,0,-256,0,1,-192,0,0,1 };
    f64 MovBa[9] = { 1,0,256,0,1,192,0,0,1 };
    f64 Skew[9] = { 1,skw,0,0,1,0,0,0,1 };
    f64 Scale[9] = { 1,0,0,0,1,0,0,0,scale };
    f64 Proj[9] = { 1,0,0,0,1,0,px,py,1 };

    f64 R_Inv[9], T_Inv[9], MF_Inv[9], MB_Inv[9], SK_Inv[9], S_Inv[9], P_Inv[9];  // Inverse Matrices
    f64 HI[9];    // Inverse of H
    f64 H[9];     // Homography Matrix
    f64 Hlp[9];   // Helper Matrix

    /* Do Matrix Inversions */
    MatInv(MovFw, MF_Inv);
    MatInv(MovBa, MB_Inv);
    MatInv(Rot, R_Inv);
    MatInv(Trans, T_Inv);
    MatInv(Skew, SK_Inv);
    MatInv(Scale, S_Inv);
    MatInv(Proj, P_Inv);

    /* Compute total Homography Matrix */
    MatMul(MovFw, Rot, Hlp);
    MatMul(Hlp, MovBa, H);
    MatMul(H, Trans, Hlp);
    MatMul(Hlp, Skew, H);
    MatMul(H, Scale, Hlp);
    MatMul(Hlp, Proj, H);

    MatInv(H, HI); // Invert H

    Mat Orig = imread(name, IMREAD_COLOR);  // Load Original Image from Disk
    Mat CImg(384, 512, CV_8UC3);                 // Distorted Image
    Mat Rek(384,512, CV_8UC3);                 // Reconstrukted Image

    Img2Map(Orig, pSrc);                         // Fill Source with Original Image

    clock_t begin = clock();                 // Time Measurement

    //for(t=0;t<10;t++)  CalcHom(pSrc,pDst,HI);

    for (t = 0; t < 100; t++)
    {
        CalcHom_Bad(pSrc, pDst, P_Inv, S_Inv, SK_Inv, T_Inv, MB_Inv, R_Inv, MF_Inv);   /* Do all Transformations */
    }

    /* Time Measurement */
    clock_t end = clock();
    f64 elapsed_secs = f64(end - begin) / CLOCKS_PER_SEC;
    printf("Ellapsed Time CalcHom:%f [s]\n", elapsed_secs);

    Map2Img(pDst, CImg);         /* Fill Distorted Image  */
    CalcHom_Bad(pDst, pSrc, MovFw, Rot, MovBa, Trans, Skew, Scale, Proj);
    //CalcHom(pDst, pSrc, H);  /* Compute Reconstruction  */
    Map2Img(pSrc, Rek);       /* Fill Reconstructed Image  */

    /* Clear memory */
    delete[] pSrc;
    delete[] pDst;

    /* Show Images */
    imshow("Orig", Orig);
    imshow("CImg", CImg);
    imshow("Rek", Rek);
    moveWindow("Orig", 0, 500);
    moveWindow("CImg", 520, 500);
    moveWindow("Rek", 1040, 500);
    waitKey();
}
